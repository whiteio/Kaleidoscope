// lex.yy.cpp generated by reflex 3.2.7 from tokens.l

#define REFLEX_VERSION "3.2.7"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "lex.yy.cpp"
#define REFLEX_OPTION_prefix              yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define YY_NUM_RULES (24)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
  }
  virtual int yylex(void);
  int yylex(const reflex::Input& input)
  {
    in(input);
    return yylex();
  }
  int yylex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return yylex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "tokens.l"

#include <string>
#include "node.h"
#include "parser.hpp"

#define SAVE_TOKEN  yylval.string = new std::string(yytext, yyleng)
#define TOKEN(t)    (yylval.token = t)


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int yyFlexLexer::yylex(void)
{
  static const char *REGEX_INITIAL = "(?m)([\\x09\\x0a\\x20])|((?:\\Qextern\\E))|((?:\\Qreturn\\E))|([A-Z_a-z][0-9A-Z_a-z]*)|([0-9]+\\.[0-9]*)|([0-9]+)|((?:\\Q=\\E))|((?:\\Q==\\E))|((?:\\Q!=\\E))|((?:\\Q<\\E))|((?:\\Q<=\\E))|((?:\\Q>\\E))|((?:\\Q>=\\E))|((?:\\Q(\\E))|((?:\\Q)\\E))|((?:\\Q{\\E))|((?:\\Q}\\E))|((?:\\Q.\\E))|((?:\\Q,\\E))|((?:\\Q+\\E))|((?:\\Q-\\E))|((?:\\Q*\\E))|((?:\\Q/\\E))|(.)";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              yyterminate();
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule tokens.l:14: [ \t\n] :
            YY_USER_ACTION
#line 14 "tokens.l"
;
            YY_BREAK
          case 2: // rule tokens.l:15: "extern" :
            YY_USER_ACTION
#line 15 "tokens.l"
return TOKEN(TEXTERN);
            YY_BREAK
          case 3: // rule tokens.l:16: "return" :
            YY_USER_ACTION
#line 16 "tokens.l"
return TOKEN(TRETURN);
            YY_BREAK
          case 4: // rule tokens.l:17: [a-zA-Z_][a-zA-Z0-9_]* :
            YY_USER_ACTION
#line 17 "tokens.l"
SAVE_TOKEN; return TIDENTIFIER;
            YY_BREAK
          case 5: // rule tokens.l:18: [0-9]+\.[0-9]* :
            YY_USER_ACTION
#line 18 "tokens.l"
SAVE_TOKEN; return TDOUBLE;
            YY_BREAK
          case 6: // rule tokens.l:19: [0-9]+ :
            YY_USER_ACTION
#line 19 "tokens.l"
SAVE_TOKEN; return TINTEGER;

            YY_BREAK
          case 7: // rule tokens.l:21: "=" :
            YY_USER_ACTION
#line 21 "tokens.l"
return TOKEN(TEQUAL);
            YY_BREAK
          case 8: // rule tokens.l:22: "==" :
            YY_USER_ACTION
#line 22 "tokens.l"
return TOKEN(TCEQ);
            YY_BREAK
          case 9: // rule tokens.l:23: "!=" :
            YY_USER_ACTION
#line 23 "tokens.l"
return TOKEN(TCNE);
            YY_BREAK
          case 10: // rule tokens.l:24: "<" :
            YY_USER_ACTION
#line 24 "tokens.l"
return TOKEN(TCLT);
            YY_BREAK
          case 11: // rule tokens.l:25: "<=" :
            YY_USER_ACTION
#line 25 "tokens.l"
return TOKEN(TCLE);
            YY_BREAK
          case 12: // rule tokens.l:26: ">" :
            YY_USER_ACTION
#line 26 "tokens.l"
return TOKEN(TCGT);
            YY_BREAK
          case 13: // rule tokens.l:27: ">=" :
            YY_USER_ACTION
#line 27 "tokens.l"
return TOKEN(TCGE);

            YY_BREAK
          case 14: // rule tokens.l:29: "(" :
            YY_USER_ACTION
#line 29 "tokens.l"
return TOKEN(TLPAREN);
            YY_BREAK
          case 15: // rule tokens.l:30: ")" :
            YY_USER_ACTION
#line 30 "tokens.l"
return TOKEN(TRPAREN);
            YY_BREAK
          case 16: // rule tokens.l:31: "{" :
            YY_USER_ACTION
#line 31 "tokens.l"
return TOKEN(TLBRACE);
            YY_BREAK
          case 17: // rule tokens.l:32: "}" :
            YY_USER_ACTION
#line 32 "tokens.l"
return TOKEN(TRBRACE);

            YY_BREAK
          case 18: // rule tokens.l:34: "." :
            YY_USER_ACTION
#line 34 "tokens.l"
return TOKEN(TDOT);
            YY_BREAK
          case 19: // rule tokens.l:35: "," :
            YY_USER_ACTION
#line 35 "tokens.l"
return TOKEN(TCOMMA);

            YY_BREAK
          case 20: // rule tokens.l:37: "+" :
            YY_USER_ACTION
#line 37 "tokens.l"
return TOKEN(TPLUS);
            YY_BREAK
          case 21: // rule tokens.l:38: "-" :
            YY_USER_ACTION
#line 38 "tokens.l"
return TOKEN(TMINUS);
            YY_BREAK
          case 22: // rule tokens.l:39: "*" :
            YY_USER_ACTION
#line 39 "tokens.l"
return TOKEN(TMUL);
            YY_BREAK
          case 23: // rule tokens.l:40: "/" :
            YY_USER_ACTION
#line 40 "tokens.l"
return TOKEN(TDIV);

            YY_BREAK
          case 24: // rule tokens.l:42: . :
            YY_USER_ACTION
#line 42 "tokens.l"
printf("Unknown token!\n"); yyterminate();

            YY_BREAK
        }
  }
}
